## 常用设计模式
设计模式可以分为三大类：**创建型模式**、**结构型模式**、**行为型模式**。

### 1. 创建型模式
这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用`new`直接实例化对象。

#### 1.1 单例模式
单例模式（Singleton Pattern）是保证一个类有且仅有一个对象（实例）的一种机制，用来控制某些事物只允许一个个体，比如一个班级只有一个班主任。

应用场景：
- 希望这个类有且仅有一个对象（实例）；
- 项目中的一些全局管理类可以用单例模式来实现。



### 2. 结构型模式
这些设计模式关注类和对象的组合。

#### 2.1 装饰器模式
装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

应用场景：
- 有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长时；
- 需要动态的增加或撤销功能时。

#### 2.2 适配器模式
适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁，这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。

应用场景：
- 系统需要使用现有的类，而这些类的接口不符合现有系统的要求；
- 对已有的系统拓展新功能，尤其适用于在设计良好的系统框架下增加接入第三方的接口或第三方的SDK。

### 3. 行为型模式
这些模式特别关注对象之间的通信。

#### 3.1 状态模式
状态模式（State Pattern），类的行为是基于它的状态改变的。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的`context`对象。

应用场景：
- 行为随着状态的改变而改变，一个对象有多种状态，在不同状态下所表现出来的行为和属性不一样；
- 条件、分支语句的代替者，一个操作中含有庞大的多分支的条件语句，这些分支依赖于该对象的状态，且每一个分支的业务逻辑都非常复杂时，我们可以使用状态模式来拆分不同的分支逻辑。

#### 3.2 观察者模式
观察者模式（Observer Pattern），对象间存在一对多关系，当一个对象被修改时，则会自动通知依赖它的对象。

应用场景：
- 对一个对象状态或数据的更新需要其他对象同步更新，或者一个对象的更新需要依赖另一个对象的更新。
- 对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节，如消息推送。